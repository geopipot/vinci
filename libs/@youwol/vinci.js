!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s(require("@youwol/dataframe")):"function"==typeof define&&define.amd?define("@youwol/vinci",["@youwol/dataframe"],s):"object"==typeof exports?exports["@youwol/vinci"]=s(require("@youwol/dataframe")):t["@youwol/vinci"]=s(t["@youwol/dataframe"])}("undefined"!=typeof self?self:this,(t=>(()=>{"use strict";var s={595:s=>{s.exports=t}},e={};function i(t){var r=e[t];if(void 0!==r)return r.exports;var h=e[t]={exports:{}};return s[t](h,h.exports,i),h.exports}i.d=(t,s)=>{for(var e in s)i.o(s,e)&&!i.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:s[e]})},i.o=(t,s)=>Object.prototype.hasOwnProperty.call(t,s),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{function t(t,s){return(t[0]-s[0])**2+(t[1]-s[1])**2}function s(t,s){return[s[0]-t[0],s[1]-t[1]]}function e(t){return t[0]**2+t[1]**2}function h(t,s){return[s[0]+t[0],s[1]+t[1]]}function n(t,s){return[t[0]*s,t[1]*s]}i.r(r),i.d(r,{Axis:()=>d,BBox:()=>a,BC:()=>_,Coulomb:()=>v,Dic:()=>C,Fault:()=>b,FaultBuilder:()=>p,LithostaticStress:()=>M,Material:()=>y,Model:()=>w,RemoteStress:()=>B,RotationalStress:()=>V,Segment:()=>m,Seidel:()=>z,Solution:()=>E,System:()=>P,Tic:()=>x,UserDic:()=>T,UserRemoteStress:()=>I,UserTic:()=>S,applyRemotes:()=>c,cauchy:()=>l,distToSegment:()=>f,distToSegment2:()=>u,dxfDecoder:()=>$});class o{constructor(){this.isContructing=!1,this.n_=0,this.EPS=1e-12}beginConstruction(t){if(this.isContructing)throw new Error("Lu is already in construction mode");this.isContructing=!0,this.n_=t,this.a_=void 0,this.a_=new Array(t).fill(void 0);for(let s=0;s<t;++s)this.a_[s]=new Array(t).fill(0)}setValue(t,s,e){if(!1===this.isContructing)throw new Error("missing call to beginConstruction");if(t>=this.n_)throw new Error(`i (${t}) is out of range (${this.n_})`);if(s>=this.n_)throw new Error(`j (${t}) is out of range (${this.n_})`);this.a_[t][s]=e}endContruction(){if(!1===this.isContructing)throw new Error("missing call to beginConstruction");this.isContructing=!1,this.decompose()}evaluate(t){if(this.isContructing)throw new Error("Lu is in construction mode, cannot evaluate.");let s=0,e=0,i=0;const r=[...t];for(let t=1;t<=this.n_;t++){if(e=this.indx[t-1],i=r[e-1],r[e-1]=r[t-1],s)for(let e=s;e<=t-1;e++)i-=this.a_[t-1][e-1]*r[e-1];else i&&(s=t);r[t-1]=i}for(let t=this.n_;t>=1;t--){i=r[t-1];for(let s=t+1;s<=this.n_;s++)i-=this.a_[t-1][s-1]*r[s-1];r[t-1]=i/this.a_[t-1][t-1]}return r}release(){if(this.isContructing)throw new Error("Lu is in construction mode. Cannot release.");this.n_=0,this.a_=void 0,this.indx=void 0,this.isContructing=!1}decompose(){let t=0,s=0,e=0,i=0,r=0;const h=new Array(this.n_).fill(0);this.indx=new Array(this.n_).fill(0);for(let t=1;t<=this.n_;t++){s=0;for(let e=1;e<=this.n_;e++)(r=Math.abs(this.a_[t-1][e-1]))>s&&(s=r);if(0==s)throw new Error("Singular matrix in routine lu.decompose");h[t-1]=1/s}for(let r=1;r<=this.n_;r++){for(let t=1;t<r;t++){i=this.a_[t-1][r-1];for(let s=1;s<t;s++)i-=this.a_[t-1][s-1]*this.a_[s-1][r-1];this.a_[t-1][r-1]=i}s=0;for(let n=r;n<=this.n_;n++){i=this.a_[n-1][r-1];for(let t=1;t<r;t++)i-=this.a_[n-1][t-1]*this.a_[t-1][r-1];this.a_[n-1][r-1]=i,(e=h[n-1]*Math.abs(i))>=s&&(s=e,t=n)}if(r!=t){for(let s=1;s<=this.n_;s++)e=this.a_[t-1][s-1],this.a_[t-1][s-1]=this.a_[r-1][s-1],this.a_[r-1][s-1]=e;h[t-1]=h[r-1]}if(this.indx[r-1]=t,0==this.a_[r-1][r-1]&&(this.a_[r-1][r-1]=this.EPS),r!=this.n_){e=1/this.a_[r-1][r-1];for(let t=r+1;t<=this.n_;t++)this.a_[t-1][r-1]*=e}}}}class a{constructor(t,s){if(this.min_=[0,0],this.max_=[0,0],this.empty_=!1,this.reset(),t&&s)for(let e=0;e<2;++e){const i=Math.min(t[e],s[e]),r=Math.max(t[e],s[e]);Math.abs(r-i)>=1e-12?(this.min_[e]=i,this.max_[e]=r):(this.min_[e]=r,this.max_[e]=r),r<i&&(this.empty_=!0)}}reset(){this.empty_=!0,this.min_=[1e32,1e32],this.max_=[-1e32,-1e32]}get empty(){return this.empty_}get min(){return[...this.min_]}get max(){return[...this.max_]}get xLength(){return this.max_[0]-this.min_[0]}get yLength(){return this.max_[1]-this.min_[1]}get sizes(){return[this.xLength,this.yLength]}get center(){let t=[...this.min_];return t=n(h(t,this.max_),.5),t}get radius(){return t=s(this.min_,this.max_),Math.sqrt(t[0]**2+t[1]**2)/2;var t}scale(t){const e=h(n(s(this.center,this.min),t),this.center),i=h(n(s(this.center,this.max),t),this.center);this.min_=e,this.max_=i}grow(t){if(this.empty_=!1,t instanceof a)this.grow(t.min),this.grow(t.max);else for(let s=0;s<2;++s)t[s]<this.min_[s]&&(this.min_[s]=t[s]),t[s]>this.max_[s]&&(this.max_[s]=t[s])}contains(t,s=0){if(t instanceof a)return!0===this.contains(t.min,s)&&!0===this.contains(t.max,s);const e=t;for(let t=0;t<2;++t)if(e[t]<this.min_[t]-s||e[t]>this.max_[t]+s)return!1;return!0}inside(t,s=0){return this.contains(t,s)}getIntersection(t){if(!1===this.intersect(t))return new a;const s=[0,0],e=[0,0];for(let i=0;i<2;++i)this.min_[i]>=t.min_[i]?s[i]=this.min_[i]:s[i]=t.min_[i],this.max_[i]<=t.max_[i]?e[i]=this.max_[i]:e[i]=t.max_[i];return new a(s,e)}intersect(t){let s=!0;for(let e=0;e<2;++e)s=s&&this.min_[e]<=t.max_[e]&&t.min_[e]<=this.max_[e];return s}}function c(t){t.faults.forEach((t=>{t.elements.forEach((t=>{t.setBcValues([0,0])}))})),t.remotes.forEach((s=>{t.faults.forEach((t=>{t.elements.forEach((t=>{const e=l(s.at(t.center),t.normal);t.addBcValues(e)}))}))}))}function l(t,s){return[t[0]*s[0]+t[1]*s[1],t[1]*s[0]+t[2]*s[1]]}function u(s,e,i){const r=t(e,i);if(0==r)return t(s,e);const h=i[0]-e[0],n=i[1]-e[1];let o=((s[0]-e[0])*h+(s[1]-e[1])*n)/r;return o=Math.max(0,Math.min(1,o)),t(s,[e[0]+o*h,e[1]+o*n])}function f(t,s,e){return Math.sqrt(u(t,s,e))}var _,d;!function(t){t[t.Traction=0]="Traction",t[t.Burger=1]="Burger"}(_||(_={})),function(t){t[t.shear=0]="shear",t[t.normal=1]="normal"}(d||(d={}));class m{constructor(t,s){this.begin=t,this.end=s,this.sin=0,this.cos=0,this.l2=0,this.bcType_=[_.Traction,_.Traction],this.burger_=[0,0],this.bcValue_=[0,0],this.mat=void 0,this.c=n(h(t,s),.5);const e=(i=this.begin,r=this.end,Math.sqrt((r[0]-i[0])**2+(r[1]-i[1])**2));var i,r;this.sin=(this.end[1]-this.begin[1])/e,this.cos=(this.end[0]-this.begin[0])/e,this.l2=e/2}get center(){return this.c}get normal(){return[-this.sin,this.cos]}get burger(){return this.burger_}set burger(t){var s,e;s=t,(e=this.burger_)[0]=s[0],e[1]=s[1]}setBurger(t,s){this.burger_[t]=s}bcType(t){return this.bcType_[t]}setBcType(t,s){this.bcType_[t]=s}get bcValues(){return this.bcValue_}bcValue(t){return this.bcValue_[t]}setBcValue(t,s){this.bcValue_[t]=s}setBcValues(t){this.bcValue_[0]=t[0],this.bcValue_[1]=t[1]}addBcValues(t){this.bcValue_[0]+=t[0],this.bcValue_[1]+=t[1]}get dof(){return(this.bcType_[0]===_.Traction?1:0)+(this.bcType_[1]===_.Traction?1:0)}bounds(){return new a(this.begin,this.end)}tooClose(t,s=1){return u(t,this.begin,this.end)<s**2*this.l2**2}toLocal(t){return[(t[0]-this.c[0])*this.cos+(t[1]-this.c[1])*this.sin,-(t[0]-this.c[0])*this.sin+(t[1]-this.c[1])*this.cos]}toGlobal(t){return[(t[0]-this.c[0])*this.cos-(t[1]-this.c[1])*this.sin,(t[0]-this.c[0])*this.sin+(t[1]-this.c[1])*this.cos]}displNegPos(){const t=this.displ(this.c),s=t[0]*this.cos+t[1]*this.sin,e=-t[0]*this.sin+t[1]*this.cos;return{neg:[s,e],pos:[s-this.burger_[0],e-this.burger_[1]]}}displ(t){const s=this.displCoeff(t),e=this.burger_[0],i=this.burger_[1];return[s[0][0]*e+s[0][1]*i,s[1][0]*e+s[1][1]*i]}stress(t){const s=this.stressCoeff(t),e=this.burger_[0],i=this.burger_[1];return[s[0][0]*e+s[0][1]*i,s[1][0]*e+s[1][1]*i,s[2][0]*e+s[2][1]*i]}displAndStress(t){const{displ:s,stress:e}=this.displAndStressCoeff(t),i=this.burger_[0],r=this.burger_[1];return{displ:[s[0][0]*i+s[0][1]*r,s[1][0]*i+s[1][1]*r],stress:[e[0][0]*i+e[0][1]*r,e[1][0]*i+e[1][1]*r,e[2][0]*i+e[2][1]*r]}}displIcAt(t){const s=this.displCoeff(t),e=this.sin,i=this.cos;return[[s[0][0]*i+s[1][0]*e,s[0][1]*i+s[1][1]*e],[-s[0][0]*e+s[1][0]*i,-s[0][1]*e+s[1][1]*i]]}tractionIcAt(t){const s=this.stressCoeff(t),e=this.sin,i=this.cos,r=i**2,h=e**2,n=e*i;return[[(s[1][0]-s[0][0])*n+s[2][0]*(r-h),(s[1][1]-s[0][1])*n+s[2][1]*(r-h)],[s[0][0]*h-2*s[2][0]*n+s[1][0]*r,s[0][1]*h-2*s[2][1]*n+s[1][1]*r]]}displCoeff(t){if(void 0===this.mat)throw new Error("material is not set");const s=this.mat.con,e=this.mat.pr1,i=this.mat.pr2,r=t[0],h=t[1],n=this.c[0],o=this.c[1],a=this.cos,c=this.sin,l=this.l2,u=(r-n)*a+(h-o)*c,f=-(r-n)*c+(h-o)*a,_=(u-l)**2+f**2,d=(u+l)**2+f**2,m=.5*s*(Math.log(_)-Math.log(d));let g=0;const p=s*(f/_-f/d),b=s*((u-l)/_-(u+l)/d);g=0==f?Math.abs(u)<l?s*Math.PI:0:-s*(Math.atan((u+l)/f)-Math.atan((u-l)/f));const y=e*c*m,w=e*a*m,E=i*a*g,x=i*c*g,S=c*p-a*b,v=a*p+c*b;return[[-y+E+f*S,-w-x-f*v],[w+x-f*v,-y+E-f*S]]}stressCoeff(t){if(void 0===this.mat)throw new Error("material is not set");const s=this.mat.con,e=this.mat.cons,i=t[0],r=t[1],h=this.c[0],n=this.c[1],o=this.cos,a=this.sin,c=this.l2,l=o**2,u=a**2,f=l-u,_=2*a*o,d=(i-h)*o+(r-n)*a,m=-(i-h)*a+(r-n)*o,g=(d-c)**2+m*m,p=(d+c)**2+m*m,b=s*(m/g-m/p),y=s*((d-c)/g-(d+c)/p),w=s*(((d-c)**2-m**2)/g**2-((d+c)**2-m**2)/p**2),E=2*s*m*((d-c)/g**2-(d+c)/p**2),x=_*w+f*E,S=m*(f*w-_*E);return[[e*(2*l*b+_*y+S),e*(m*x-y)],[e*(2*u*b-_*y-S),-e*(y+m*x)],[e*(_*b-f*y+m*x),-e*S]]}displAndStressCoeff(t){if(void 0===this.mat)throw new Error("material is not set");const s=this.mat.con,e=this.mat.pr1,i=this.mat.pr2,r=this.mat.cons,h=this.l2,n=t[0],o=t[1],a=this.c[0],c=this.c[1],l=this.cos,u=this.sin,f=l**2,_=u**2,d=f-_,m=2*u*l,g=(n-a)*l+(o-c)*u,p=-(n-a)*u+(o-c)*l,b=(g-h)**2+p**2,y=(g+h)**2+p**2,w=.5*s*(Math.log(b)-Math.log(y));let E;const x=s*(p/b-p/y),S=s*((g-h)/b-(g+h)/y),v=s*(((g-h)**2-p**2)/b**2-((g+h)**2-p**2)/y**2),C=2*s*p*((g-h)/b**2-(g+h)/y**2);E=0==p?Math.abs(g)<h?s*Math.PI:0:-s*(Math.atan((g+h)/p)-Math.atan((g-h)/p));const T=e*u*w,B=e*l*w,M=i*l*E,A=i*u*E,I=u*x-l*S,V=l*x+u*S,P=m*v+d*C,z=p*(d*v-m*C);return{displ:[[-T+M+p*I,-B-A-p*V],[B+A-p*V,-T+M-p*I]],stress:[[r*(2*f*x+m*S+z),r*(p*P-S)],[r*(2*_*x-m*S-z),-r*(S+p*P)],[r*(m*x-d*S+p*P),-r*z]]}}setMaterial(t){this.mat=t}}var g=i(595);class p{constructor(t){this.model=t,this.prev=void 0,this.fault_=new b}get fault(){return this.fault_}reset(){return this.fault_=new b,this.prev=void 0,this}addToModel(){return void 0===this.model?console.warn("Model is not set while calling done()"):this.model.addFault(this.fault_),this}addPoint(t){return void 0!==this.prev&&(this.fault_.addElement(new m(this.prev,t)),this.prev=[...t]),this.prev=[...t],this}setPoints(t){return Array.isArray(t)?g.Serie.create({array:t,itemSize:2}).forEach((t=>this.addPoint(t))):t.forEach((t=>this.addPoint(t))),this}subdivide(t=2){if(t<2)return this;const e=new b;return this.fault_.elements.forEach((i=>{let r=i.begin,o=r;const a=n(s(r,i.end),1/t);for(let s=0;s<t;++s)o=h(o,a),e.addElement(new m(r,o)),r=o})),this.fault_=e,this}setBcType(t){return this.fault_.bcType=t,this}setBurger(t){return this.fault_.burgers=t,this}addTic(t){return this.fault_.addTic(t),this}addDic(t){return this.fault_.addDic(t),this}setBurgersForAxis(t,s){if(s instanceof g.Serie){if(1!==s.itemSize)throw new Error(`burgers itemSize (${s.itemSize}) should be 1`);if(s.count!==this.fault_.elements.length)throw new Error(`burgers count (${s.count}) should be equals to the number of segments (${this.fault_.elements.length})`);this.fault_.elements.forEach(((e,i)=>{const r=s.array[i];e.burger[t]=r}))}else if(Array.isArray(s)&&s.length===this.fault_.elements.length)this.fault_.elements.forEach(((e,i)=>{e.burger[t]=s[i]}));else{if("number"!=typeof s)throw new Error("don't know how to set the burgers (bad argument)");this.fault_.elements.forEach((e=>{e.burger[t]=s}))}return this}}class b{constructor(t){if(this.segs_=[],this.bc=[_.Traction,_.Burger],this.material_=void 0,this.tics_=[],this.dics_=[],void 0!==t)if(t instanceof p)t.fault.elements.forEach((t=>this.addElement(t)));else{const s=new p;s.setPoints(t),s.fault.elements.forEach((t=>this.addElement(t)))}}get elements(){return this.segs_}get dof(){return this.segs_.reduce(((t,s)=>t+s.dof),0)}addElement(t){this.segs_.push(t),this.material_&&t.setMaterial(this.material_)}addTic(t){this.tics_.push(t)}get tics(){return this.tics_}addDic(t){this.dics_.push(t)}get dics(){return this.dics_}tooClose(t,s=1){for(let e=0;e<this.segs_.length;++e)if(this.segs_[e].tooClose(t,s))return!0;return!1}get bounds(){const t=new a;return this.segs_.forEach((s=>{t.grow(s.begin),t.grow(s.end)})),t}get bcType(){return this.bc}set bcType(t){for(let s=0;s<2;++s)if("string"==typeof t[s])switch(t[s]){case"t":this.setBcType_(s,_.Traction);break;case"b":this.setBcType_(s,_.Burger);break;default:throw new Error(`Unknown bc type ${t}. Should be "t" or "b"`)}else this.setBcType_(s,t[s])}set burgers(t){if(t instanceof g.Serie){if(t.itemSize<2)throw new Error(`burgers itemSize (${t.itemSize}) should be >= 2`);if(t.count!==this.elements.length)throw new Error(`burgers count (${t.count}) should be equals to the number of segments (${this.elements.length})`);this.elements.forEach(((s,e)=>{const i=t.itemAt(e);s.burger=[i[0],i[1]]}))}else if(Array.isArray(t)&&t.length===2*this.elements.length)this.elements.forEach(((s,e)=>{s.burger=[t[2*e],t[2*e+1]]}));else{if(!Array.isArray(t)||2!==t.length)throw new Error("don't know how to set the burgers (bad argument)");this.elements.forEach((s=>{s.burger=[t[0],t[1]]}))}}get burgers(){const t=[];return this.elements.forEach((s=>{t.push(...s.burger)})),t}get burgersAsSerie(){const t=(0,g.createEmptySerie)({Type:Float32Array,count:this.elements.length,itemSize:2,dimension:2,shared:!1});return this.elements.forEach(((s,e)=>t.setItemAt(e,s.burger))),t}setBcType_(t,s){this.bc[t]=s,this.segs_.forEach((e=>{e.setBcType(t,s)}))}set material(t){this.material_=t,this.segs_.forEach((s=>{s.setMaterial(t)}))}}class y{constructor(t,s,e=1){this.rho=1,this.pr=.25,this.e=1,this.con_=1/(4*Math.PI*(1-this.pr)),this.cons_=this.e/(1+this.pr),this.pr1_=1-2*this.pr,this.pr2_=2*(1-this.pr),this.pr=t,this.e=s,this.rho=e}get poisson(){return this.pr}set poisson(t){this.pr=t,this.update()}get young(){return this.e}set young(t){this.e=t,this.update()}get density(){return this.rho}set density(t){this.rho=t}get con(){return this.con_}get cons(){return this.cons_}get pr1(){return this.pr1_}get pr2(){return this.pr2_}update(){this.con_=1/(4*Math.PI*(1-this.pr)),this.cons_=this.e/(1+this.pr),this.pr1_=1-2*this.pr,this.pr2_=2*(1-this.pr)}}class w{constructor(){this.faults_=[],this.remotes_=[],this.material_=new y(.25,1,1)}get faults(){return this.faults_}clear(){this.faults_=[],this.remotes_=[]}setMaterial(t,s,e){this.material_.poisson=t,this.material_.young=s,this.material_.density=e,this.faults_.forEach((t=>{t.material=this.material_}))}get material(){return this.material_}get dof(){return this.faults_.reduce(((t,s)=>t+s.dof),0)}addRemote(t){this.remotes_.push(t)}get remotes(){return this.remotes_}addFault(t){this.faults_.push(t),t.material=this.material_}tooClose(t,s=1){for(let e=0;e<this.faults_.length;++e)if(this.faults_[e].tooClose(t,s))return!0;return!1}get bounds(){const t=new a;return this.faults_.forEach((s=>{t.grow(s.bounds)})),t}}class E{constructor(t){this.model=t}burgers(){return this.model.faults.map((t=>t.burgersAsSerie))}displ(t,s=!0){const e=s?2:3,i=(0,g.createEmptySerie)({Type:Float32Array,count:t.count,itemSize:e,dimension:e,shared:!1});let r=0;return t.forEach((t=>{const s=[0,0];this.model.faults.forEach((e=>{e.elements.forEach((e=>{const i=e.displ(t);s[0]+=i[0],s[1]+=i[1]}))})),i.array[r++]=s[0],i.array[r++]=s[1],e>2&&(i.array[r++]=0)})),i}stress(t){if(t.itemSize<2)throw new Error("itemSize for points should be at least 2");const s=(0,g.createEmptySerie)({Type:Float32Array,count:t.count,itemSize:3,dimension:2,shared:!1});let e=0;return t.forEach((t=>{const i=[0,0,0];this.model.faults.forEach((s=>{s.elements.forEach((s=>{const e=s.stress(t);i[0]+=e[0],i[1]+=e[1],i[2]+=e[2]}))})),s.array[e++]=i[0],s.array[e++]=i[1],s.array[e++]=i[2]})),s}}class x{}class S extends x{constructor(t){super(),this.cb=t}do(t){return this.cb(t)}}class v extends x{constructor(t,s,e=0,i="coucou"){super(),this.friction=t,this.cohesion=s,this.lambda=e,this.s=i}do(t){if(t[1]>0)return t;const s=t[1],e=Math.abs(t[0]),i=this.friction*s*(1-this.lambda)+this.cohesion;if(e>i){const s=1-i/e;t[0]=s*t[0]}return t[1]=0,t}}class C{do(t){return[0,0]}}class T extends C{constructor(t){super(),this.cb=t}do(t){return this.cb(t)}}class B{constructor(t){this.stress=t}at(t){return[...this.stress]}}class M{constructor(t,s){this.density=t,this.ratio=s}at(t){const s=9.81*this.density*t[1];return[s*this.ratio,0,s]}}const A=t=>[0,0,0];class I{constructor(t){this.cb_=A,this.cb_=t}setFunction(t){this.cb_=t}at(t){return this.cb_(t)}}class V{constructor(t,s,e){this.theta_=0,this.S1_=0,this.S2_=0,this.s=0,this.c=0,this.theta_=e,this.S1_=t,this.S2_=s;const i=this.theta_*Math.PI/180;this.c=Math.cos(i),this.s=Math.sin(i)}set theta(t){this.theta_=t;const s=this.theta_*Math.PI/180;this.c=Math.cos(s),this.s=Math.sin(s)}get theta(){return this.theta_}set S1(t){this.S1_=t}get S1(){return this.S1_}set S2(t){this.S2_=t}get S2(){return this.S2_}at(t){return[this.S1_*this.c**2+this.S2_*this.s**2,(this.S2_-this.S1_)*this.c*this.s,this.S1_*this.s**2+this.S2_*this.c**2]}}class P{constructor(t,s,e){this.fault=e,this.lu=new o,this.ts_=void 0,this.rts_=void 0,this.dof_=0,this.dof2_=0,this.ts_=[...t],this.dof_=t.reduce(((t,s)=>t+s.dof),0),this.initialize(s)}solve(){if(0!==this.dof_)return this.getTotalTraction(this.x_),this.applyTics(this.x_),this.lu.evaluate(this.x_),this.applyDics(this.x_),this.setSolution()}initialize(t){this.dof2_=0,this.rts_=[],t.faults.forEach((t=>{t.elements.forEach((t=>{this.ts_.includes(t)||(this.rts_.push(t),this.dof2_+=t.dof)}))})),this.b_=new Array(this.dof_).fill(0),this.cstRhs_=new Array(this.dof_).fill(0),this.x_=new Array(this.dof_).fill(0),this.B_=function(t,s){const e=new Array(t).fill(void 0);for(let i=0;i<t;++i)e[i]=new Array(s).fill(0);return e}(this.dof_,this.dof2_);let s,e,i=0;this.ts_.forEach((t=>{for(let s=0;s<2;++s)t.bcType(s)===_.Traction?this.b_[i++]=-t.bcValue(s):t.setBurger(s,t.bcValue(s))})),this.lu.beginConstruction(this.dof_);let r=0;this.ts_.forEach((t=>{if(t.dof>0){let i=0;this.ts_.forEach((h=>{const n=h.tractionIcAt(t.center);s=0;for(let o=0;o<2;++o)if(t.bcType(o)===_.Traction){e=0;for(let t=0;t<2;++t)if(h.bcType(t)===_.Traction)this.lu.setValue(r+s,i+e,n[o][t]),++e;else{const e=n[o][t]*h.burger[t];this.cstRhs_[r+s]-=e}++s}i+=e})),r+=s}})),this.lu.endContruction(),r=0,this.ts_.forEach((t=>{if(t.dof>0){let i=0;this.rts_.forEach((h=>{const n=h.tractionIcAt(t.center);s=0;for(let o=0;o<2;++o)if(t.bcType(o)===_.Traction){e=0;for(let t=0;t<2;++t)if(h.bcType(t)===_.Traction)this.B_[r+s][i+e]=-n[o][t],++e;else{const e=n[o][t]*h.burger[t];this.cstRhs_[r+s]-=e}++s}i+=e})),r+=s}}))}setSolution(){let t=0,s=0;return this.ts_.forEach((i=>{const r=e(i.burger);for(let s=0;s<2;++s)i.bcType(s)==_.Traction&&(i.setBurger(s,this.x_[t]),t++);const h=e(i.burger);s+=Math.abs(h-r)})),s}getTotalTraction(t){let s=0;this.ts_.forEach((t=>{for(let e=0;e<2;++e)t.bcType(e)===_.Traction&&(this.b_[s]=-(t.bcValue(e)+this.cstRhs_[s]),s++)}));const e=new Array(this.dof2_).fill(0);let i=0;var r,h,n,o;this.rts_.forEach((t=>{for(let s=0;s<2;++s)t.bcType(s)==_.Traction&&(e[i++]=t.burger[s])})),r=this.B_,h=e,n=this.b_,function(t,s,e){const i=t.length,r=t[0].length;for(let h=0;h<i;++h){e[h]=0;for(let i=0;i<r;++i)e[h]+=t[h][i]*s[i]}}(r,h,o=t),function(t,s){t.forEach(((e,i)=>{s[i]+=t[i]}))}(n,o)}applyDics(t){return this.fault.dics.reduce(((t,s)=>s.do(t)),t)}applyTics(t){return this.fault.tics.reduce(((t,s)=>s.do(t)),t)}}class z{set messageCB(t){this.msgCB=t}set warningCB(t){this.warCB=t}set errorCB(t){this.errCB=t}set iterationCB(t){this.iterCB=t}set tol(t){this.tol_=t}set maxIter(t){this.maxIter_=t}constructor({tol:t=1e-7,maxIter:s=200,model:e}={}){this.model=void 0,this.systems=[],this.tol_=1e-7,this.maxIter_=200,this.warCB=t=>{},this.errCB=t=>{},this.msgCB=t=>{},this.stopCB=void 0,this.iterCB=void 0,this.valid_=!1,this.tol_=t,this.maxIter_=s,e&&this.setup(e)}setup(t){return this.model=t,this.model.faults.forEach((s=>{s.elements.forEach((e=>{if(this.systems.push(new P([e],t,s)),this.stopCB&&this.stopCB())return this.warCB("solver initialization stopped by user"),this.valid_=!1,!1}))})),this.valid_=!0,!0}run(){if(!this.valid_)return void this.errCB("Cannot run the solver, initiallization was stopped by user");c(this.model),this.msgCB("Solving the system...");let t=1,s=0;for(;t>this.tol_;){if(s++,t=0,this.systems.forEach((s=>{t+=s.solve()})),s>this.maxIter_){this.warCB&&this.warCB(`solver max iter reached (${this.maxIter_}). Exiting...`);break}if(s%10==0){if(this.stopCB&&this.stopCB()){this.warCB("solver stopped by user. Exiting...");break}this.msgCB(`iteration ${s}, convergence ${t}`)}this.iterCB&&this.iterCB(t,s)}this.msgCB("Solver ended.")}}function $(t){const s=t.split("\n"),e=[];let i=0;const r=()=>{for(;;){if(i>=s.length)return;const t=s[i++];if(0!==t.length){const s=t.split(" ");if(0!==s.length)return s}}};for(;;){const t=r();if(void 0===t)break;if("LINE"===t[0]){r(),r(),r();const t=parseFloat(r()[0]);r();const s=parseFloat(r()[0]);r();const i=parseFloat(r()[0]);r();const h=parseFloat(r()[0]);e.push([t,s,i,h])}}return e}})(),r})()));
//# sourceMappingURL=vinci.js.map